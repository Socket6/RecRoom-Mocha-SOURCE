#pragma once
#include "Respawns.h"
#include "Teleports.h"

bool CacheOpRaiseEventArgs(PhotonPlayer* targetPP)
{
    std::unique_lock<std::timed_mutex> opRaiseEventLock(globals::opRaiseEventMutex, std::defer_lock);
    if (opRaiseEventLock.try_lock_for(std::chrono::seconds(globals::opRaiseEventMutexTimeout)))
    {
        globals::opRaiseEventCached = false;
        bool previousIHookState = globals::Ihooks::OpRaiseEvent;

        if (pHookManager->hookPriority == HookManager::HookType::PAGEGUARD)
        {
            globals::veh::opRaiseEvent = true;

            if (!pHookManager->UpdateHooks())
            {
                Log::error("rehook failed!");
                opRaiseEventLock.unlock();
                return false;
            }
        }
        else
        {
            globals::Ihooks::OpRaiseEvent = true;
        }

        Callbacks::SpawnPlayerTarget(targetPP); // so we can cache valid params for OpRaiseEvent
        Callbacks::SpawnPlayerTarget(targetPP); // so we can cache valid params for OpRaiseEvent

        if (pHookManager->hookPriority == HookManager::HookType::PAGEGUARD)
        {
            globals::veh::opRaiseEvent = false;

            if (!pHookManager->UpdateHooks())
            {
                Log::error("rehook failed!");
                opRaiseEventLock.unlock();
                return false;
            }
        }
        else
        {
            globals::Ihooks::OpRaiseEvent = previousIHookState;
        }

        globals::opRaiseEventCached = false;

        opRaiseEventLock.unlock();

        if ((OpRaiseEventCache::instance != nullptr) && (OpRaiseEventCache::eventOptions != nullptr) && (
            OpRaiseEventCache::sendOptions != nullptr))
            return true;
    }
    else
    {
        Log::error("opRaiseEventLock timed out in CacheOpRaiseEventArgs!");
    }
    return false;
}

namespace Callbacks
{
    bool DestroyPhotonPlayerTarget(PhotonPlayer* targetPP)
    {
        if (targetPP != nullptr && localPlayerExists && localPlayer.loadingStage >= LoadingStage::LOADED)
        {
            if (!CacheOpRaiseEventArgs(targetPP))
                return false;

            std::unique_lock lock(playerlistMutex, std::defer_lock);

            if (lock.try_lock_for(std::chrono::milliseconds(globals::playerlistMutexTimeout)))
            {
                // we lock & unlock mutex in CacheOpRaiseEventArgs and we also set master client there too

                if (!cachedPlayerlist.contains(targetPP))
                {
                    lock.unlock();
                    return true;
                }

                const auto internalCachedInstance = static_cast<Il2CppObject*>(OpRaiseEventCache::instance);
                const auto internalCachedEventOptions = static_cast<Il2CppObject*>(OpRaiseEventCache::eventOptions);
                const auto internalCachedSendOptions = static_cast<Il2CppObject*>(OpRaiseEventCache::sendOptions);

                if (const PlayerInfo& targetPlayer = cachedPlayerlist[targetPP];
                    targetPlayer.loadingStage >= LoadingStage::LOADED && targetPlayer.photonView != nullptr)
                {
                    int actorId1 = targetPlayer.photonActorID;
                    int viewId1 = targetPlayer.photonViewID;

                    const auto rpcPayload = Hashtable::ctor();
                    rpcPayload->Add(
                        0, static_cast<UObject*>(il2cpp_value_box_spoof(FindClass("System.Int32"), &actorId1)));

                    // event 207 destroy player
                    PhotonNetwork::OpRaiseEvent(internalCachedInstance, 207, rpcPayload, internalCachedEventOptions,
                                                internalCachedSendOptions);

                    const auto event204Payload = Hashtable::ctor();
                    event204Payload->Add(
                        0, static_cast<UObject*>(il2cpp_value_box_spoof(FindClass("System.Int32"), &viewId1)));

                    // event 204 related to join/leave room
                    PhotonNetwork::OpRaiseEvent(internalCachedInstance, 204, event204Payload,
                                                internalCachedEventOptions, internalCachedSendOptions);
                }

                lock.unlock();
            }
            else
            {
                Log::error("playerlistMutex timed out in DestroyPhotonPlayerTarget");
                return false;
            }
        }
        return true;
    }

    bool ByeByeExploitTarget(PhotonPlayer* targetPP)
    {
        //todo: add Ev210 before destroying, otherwise this is patched

        if (targetPP != nullptr && localPlayerExists && localPlayer.loadingStage >= LoadingStage::LOADED)
        {
            if (!CacheOpRaiseEventArgs(targetPP))
                return false;

            std::unique_lock lock(playerlistMutex, std::defer_lock);

            if (lock.try_lock_for(std::chrono::milliseconds(globals::playerlistMutexTimeout)))
            {
                // we lock & unlock mutex in CacheOpRaiseEventArgs and we also set master client there too

                const auto internalCachedInstance = static_cast<Il2CppObject*>(OpRaiseEventCache::instance);
                const auto internalCachedEventOptions = static_cast<Il2CppObject*>(OpRaiseEventCache::eventOptions);
                const auto internalCachedSendOptions = static_cast<Il2CppObject*>(OpRaiseEventCache::sendOptions);

                if (const PlayerInfo& targetPlayer = cachedPlayerlist[targetPP];
                    targetPlayer.photonView != nullptr)
                {
                    int viewId1 = targetPlayer.photonViewID;

                    const auto rpcPayload = Hashtable::ctor();
                    rpcPayload->Add(
                        7, static_cast<UObject*>(il2cpp_value_box_spoof(FindClass("System.Int32"), &viewId1)));

                    // event 202 related to instantiate/destroy object
                    PhotonNetwork::OpRaiseEvent(internalCachedInstance, 202, rpcPayload, internalCachedEventOptions,
                                                internalCachedSendOptions);

                    const auto event204Payload = Hashtable::ctor();
                    event204Payload->Add(
                        0, static_cast<UObject*>(il2cpp_value_box_spoof(FindClass("System.Int32"), &viewId1)));

                    // event 204 related to join/leave room
                    PhotonNetwork::OpRaiseEvent(internalCachedInstance, 204, event204Payload,
                                                internalCachedEventOptions, internalCachedSendOptions);

                    for (const std::vector<int> photonViewIDs{7, 6, 4, 3, 8, 2};
                         // viewids of player body parts or something like that i think love is doing gods work here
                         const auto i : photonViewIDs)
                    {
                        const auto byePayload = Hashtable::ctor();
                        int photonViewID = std::stoi(
                            (std::to_string(targetPlayer.photonActorID) + "0000" + std::to_string(i)));
                        // this will not work in room 2.0
                        byePayload->Add(
                            0, static_cast<UObject*>(il2cpp_value_box_spoof(FindClass("System.Int32"), &photonViewID)));
                        PhotonNetwork::OpRaiseEvent(internalCachedInstance, 200, byePayload, internalCachedEventOptions,
                                                    internalCachedSendOptions);
                    }
                }

                lock.unlock();
            }
            else
            {
                Log::error("playerlistMutex timed out in ByeByeExploitTarget!");
                return false;
            }
        }
        return true;
    }

    bool FreezeTarget(PhotonPlayer* targetPP)
    {
        //todo: add Ev210 before destroying pv or else this is patched

        return true;
#ifdef freezeFixed
		std::unique_lock<std::timed_mutex> lock(playerlistMutex, std::defer_lock);

		if (lock.try_lock_for(std::chrono::milliseconds(globals::playerlistMutexTimeout))) {

			for (const auto& [_, player] : cachedPlayerlist) {
				if (player.isLocalPlayer) {
					if (!PhotonNetwork::get_isMasterClient(player.photonPlayer)) {
						if (!PhotonNetwork::set_MasterClient(player.photonPlayer))
							Log::error("Failed to set master client for: " + std::string(player.DisplayName));
						Sleep(250);
					}
					break;
				}
			}

			PlayerInfo& targetPlayer = cachedPlayerlist[targetPP];

			if (targetPlayer.photonView != nullptr) {
				Log::debug("pv not nullptr");
			}

			targetPlayer.photonView->TransferOwnership(localPlayer.photonPlayer);

			Sleep(150);

			PhotonNetwork::Destroy3(targetPlayer.photonView);

			Sleep(150);

			if (targetPlayer.photonView != nullptr) {
				Log::debug("pv not still nullptr");
			}

			targetPlayer.photonView->TransferOwnership(targetPP);

			lock.unlock();
		}
		else {
			Log::error("playerlistMutex timed out in FreezeTarget!");
		}
#endif
    }

    bool DestroyGameObject(void* ppvid)
    {
        if (ppvid != nullptr && localPlayerExists && localPlayer.loadingStage >= LoadingStage::LOADED)
        {
            int32_t pvid = *static_cast<int32_t*>(ppvid);

            if (PhotonView* targetPV = PhotonView::findPhotonView(pvid))
            {
                if (!PhotonNetwork::get_isMasterClient(localPlayer.photonPlayer))
                {
                    if (!PhotonNetwork::set_MasterClient(localPlayer.photonPlayer))
                        Log::error("Failed to set master client for: " + std::string(localPlayer.DisplayName));
                }

                PhotonNetwork::Destroy3(targetPV);
                Sleep(10);
            }

            {
                /// update OpRaiseEvent cache
                std::vector<PhotonView::PayloadEntry> payloadVector = {
                    // invalid payload so nothing actually happens
                };

                localPlayer.photonView->SendRPC("RpcAuthorityCV2SetPosition", All, payloadVector);
            }

            const auto internalCachedInstance = static_cast<Il2CppObject*>(OpRaiseEventCache::instance);
            const auto internalCachedEventOptions = static_cast<Il2CppObject*>(OpRaiseEventCache::eventOptions);
            const auto internalCachedSendOptions = static_cast<Il2CppObject*>(OpRaiseEventCache::sendOptions);

            /*
            auto rpcPayload = Hashtable::ctor();
            rpcPayload->Add((BYTE)7, (UObject*)il2cpp_value_box_spoof(FindClass("System.Int32"), &pvid));

            // ????
            PhotonNetwork::OpRaiseEvent(internalCachedInstance, (BYTE)202, (Il2CppObject*)rpcPayload, internalCachedEventOptions, internalCachedSendOptions);
            */

            const auto event204Payload = Hashtable::ctor();
            event204Payload->Add(0, static_cast<UObject*>(il2cpp_value_box_spoof(FindClass("System.Int32"), &pvid)));

            // destroy object event
            PhotonNetwork::OpRaiseEvent(internalCachedInstance, 204, event204Payload, internalCachedEventOptions,
                                        internalCachedSendOptions);

            const auto ev200payload = Hashtable::ctor();
            ev200payload->Add(0, static_cast<UObject*>(il2cpp_value_box_spoof(FindClass("System.Int32"), &pvid)));

            // sent after object destroy for some reason who knows
            PhotonNetwork::OpRaiseEvent(internalCachedInstance, 200, event204Payload, internalCachedEventOptions,
                                        internalCachedSendOptions);
        }
        else
        {
            Log::error("localPlayer is loading, cannot destroy object!");
            return false;
        }

        return true;
    }
}
