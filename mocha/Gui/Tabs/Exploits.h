#pragma once

void CGui::ExploitsTab(ImGuiStyle& style)
{
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemInnerSpacing);
    ImGui::PushFont(m_Fonts.BigFont);
    {
        ImGui::TextDisabled("Exploit Modules");
    }
    ImGui::PopFont();
    ImGui::PushStyleColor(ImGuiCol_Border, ImVec4());
    ImGui::BeginChild("Exploit Modules",
                      ImVec2(
                          0, (ImGui::GetFontSize() * 2 + style.WindowPadding.y * 4 + style.ItemInnerSpacing.y) + (style.
                              WindowPadding.y * 2 + ImGui::GetFontSize() * 6 + style.ItemInnerSpacing.y * 3) + (
                              ImGui::GetFontSize() + style.WindowPadding.y * 2) * 80), ImGuiChildFlags_Border);
    ImGui::PopStyleColor();
    ImGui::PopStyleVar();
    {
        /*
        if (ImAdd::Button("Remove Sharecam Permission", ImVec2(-0.1f, 0))) {
            newThread(&PlayerList::RemoveShareCamPL, nullptr);
        }
        ImGui::SetItemTooltip("Remove sharecamera permissions for all.");
        */

        if (ImAdd::Button("RAM Crash All Players", ImVec2(-0.1f, 0)))
        {
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::BulletCrashAll);
        }
        ImGui::SetItemTooltip("Attempt to crash all players by exploit.");

        if (ImAdd::Button("Promote All Players", ImVec2(-0.1f, 0)))
        {
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::UpdateRolesAll);
        }
        ImGui::SetItemTooltip("This promotion does not include invention or delete all permissions.");

        if (ImAdd::Button("Swap All Players", ImVec2(-0.1f, 0)))
        {
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::RotateAllPL);
        }
        ImGui::SetItemTooltip("Swap all player positions excluding yourself.");

        if (ImAdd::Button("Give all tool", ImVec2(-0.1f, 0)))
        {
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::ForceToolAll);
        }
        ImGui::SetItemTooltip(
            "Gives everyone a tool, object must have Tool component. \nCustomizable in Assets Spawn.");

        if (ImAdd::Button("Spawn Asset All", ImVec2(-0.1f, 0)))
        {
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::SpawnAssetAll);
        }
        ImGui::SetItemTooltip("Spawn Asset on all players. \nCustomizable in Assets Spawn.");

        if (ImAdd::Button("Jew Royalty", ImVec2(-0.1f, 0)))
        {
            // this doesn't require async
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::SetMasterClientTarget, localPlayer.photonPlayer);
        }
        ImGui::SetItemTooltip("Huge nose activities.");

#ifndef PROD
        
        if (ImAdd::Button("Vanish", ImVec2(-0.1f, 0)))
        {
            // we could use a mutex here as well but we only use cashedPlayerlist as a reference here so no real need to

            std::unique_lock<std::timed_mutex> lock(playerlistMutex, std::defer_lock);

            if (lock.try_lock_for(std::chrono::milliseconds(globals::playerlistMutexTimeout)))
            {
                for (auto& [photonPlayer, player] : cachedPlayerlist)
                {
                    if (player.isLocalPlayer)
                    {
                        //newThread(&PlayerList::FreezePlayerPL, photonPlayer);
                        //newThread(&PlayerList::Ev207PL, photonPlayer);

                        break;
                    }
                }

                lock.unlock();
            }
            else
            {
                Log::error("playerlistMutex timed out in Huge nose activities Button!");
            }
        }
        ImGui::SetItemTooltip(
            "Vanish is a non-toggleable invisibility exploit. \nYou can't speak or chat while in vanish. \nOthers can't see or view you on the here now/recents page while in vanish.");
#endif

        ImGui::Separator();

        ImAdd::ToggleButtonClassic("Force Leave Party", &globals::forceLeavePartyGas);
        ImGui::SetItemTooltip("Force victim to leave party if they're in one.");

        ImGui::InputTextWithHint("##89327928", "Put Room Name Here", &globals::roomNameBuffer);
        ImGui::SetItemTooltip("Room name buffer for gas.");
        
        if (ImAdd::Button("GAS All", ImVec2(-0.1f, 0)))
        {
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::GoToRoomAll);
        }
        ImGui::SetItemTooltip("The packets are \"Unreliable\" so press this a few times to get everyone.");
        
        ImGui::Separator();

        if (ImGui::CollapsingHeader("Audio Config"))
        {
            ImGui::Indent(10);
            ImAdd::BeginHighlightGroup();

            if (ImGui::CollapsingHeader("Advanced Config"))
            {
                ImGui::Indent(10);
                ImAdd::BeginHighlightGroup();

                ImGui::PushItemWidth(100);
                ImGui::InputFloat("volume ##3982", &globals::audio::volume);
                ImGui::PopItemWidth();
                ImGui::SetItemTooltip("Volume of audio.");

                ImGui::PushItemWidth(100);
                ImGui::InputFloat("speed ##3982", &globals::audio::speed);
                ImGui::PopItemWidth();
                ImGui::SetItemTooltip("Speed of audio.");

                ImAdd::ToggleButtonClassic("loop audio", &globals::audio::loop);
                ImGui::SetItemTooltip("Loop audio on audio end.");

                {
                    const char* items[] = { "Voice", "Sfx", "Music", "Ambience", "Master", "CoachVO", "VoiceCall" };
                    int current_item = globals::audio::channel;

                    ImGui::PushItemWidth(200);
                    if (ImGui::Combo("Audio Channel ##324324", &current_item, items, IM_ARRAYSIZE(items))) {
                        globals::audio::channel = current_item;
                    }
                    ImGui::PopItemWidth();
                    ImGui::SetItemTooltip("Channel which the audio will play for.");
                }

                if (ImGui::Button("Update Settings"))
                {
                    EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                                    Callbacks::UpdateAudioPlayer);
                }
                ImGui::SetItemTooltip("Update current Audio Player settings.");

                ImAdd::EndHighlightGroup();
                ImGui::Indent(-10);
            }

#ifndef PROD
            ImGui::InputTextWithHint("##89381721128", "Put Audio Name Here", &globals::audio::blobNameAudioBuffer);
            ImGui::SetItemTooltip("Audio blobName buffer for HEAT.");

            ImGui::InputFloat("Audio Length", &globals::audio::audioLength);
            ImGui::SetItemTooltip("Audio length for HEAT.");
#endif



            {
                // Static std::string to hold the filter text
                static std::string filterText = "";
                // Static character array for ImGui input (ImGui requires a mutable buffer)
                static char inputBuffer[256] = "";

                // Input text field
                if (ImGui::InputTextWithHint("##2323", "Enter Song Name Here", inputBuffer, IM_ARRAYSIZE(inputBuffer)))
                {
                    // If the input changes, update filterText
                    filterText = inputBuffer;
                }
                ImGui::SetItemTooltip("No I am NOT adding your audios. Fuck off.");

                ImGui::SameLine();
                if (ImGui::Button("Paste ##33"))
                {
                    // Paste clipboard content into filterText and sync with inputBuffer
                    const char* clipboardText = ImGui::GetClipboardText();
                    if (clipboardText)
                    {
                        filterText = clipboardText;
                        // Copy to inputBuffer, ensuring it fits within the buffer size
                        strncpy_s(inputBuffer, filterText.c_str(), sizeof(inputBuffer) - 1);
                        inputBuffer[sizeof(inputBuffer) - 1] = '\0'; // Ensure null-termination
                    }
                }

                ImGui::SameLine();
                if (ImGui::Button("Clear ##33"))
                {
                    // Clear both filterText and inputBuffer
                    filterText.clear();
                    inputBuffer[0] = '\0';
                }

                // Compute lowercase version of filterText for filtering
                std::string lowerFilterText = filterText;
                toLowercaseInPlace(lowerFilterText);

                ImGui::BeginChild("SongSelection", ImVec2(0, 200), true, ImGuiWindowFlags_None);
                // Child window with a height of 200

                static std::string selectedSongName; // Track the selected song name

                for (const auto& [songname, filename] : audioConfig)
                {
                    // Compute lowercase version of songname
                    std::string lowerSongName = songname;
                    toLowercaseInPlace(lowerSongName);

                    // Filter songs using the lowercase versions
                    if (IsSelectableFiltered(lowerSongName.c_str(), lowerFilterText.c_str()))
                    {
                        bool isSelected = (selectedSongName == songname);
                        if (ImGui::Selectable(songname.c_str(), isSelected))
                        {
                            // Since globals::audio::blobNameAudioBuffer is a std::string, assign directly
                            globals::audio::blobNameAudioBuffer = filename;
                            selectedSongName = songname;
                            ImGui::SetClipboardText(songname.c_str()); // Copy songname to clipboard
                        }
                    }
                }

                ImGui::EndChild();
            }
            
            #ifdef OLDBUFFERCODE
            {
                static char filterBuffer[256] = "";
                ImGui::InputTextWithHint("##2323", "Enter Song Name Here", filterBuffer, IM_ARRAYSIZE(filterBuffer));
                ImGui::SetItemTooltip("No I am NOT adding your audios. Fuck off.");

                ImGui::SameLine();
                if (ImGui::Button("Paste ##33"))
                {
                    const char* clipboardText = ImGui::GetClipboardText();
                    if (clipboardText)
                    {
                        if (strlen(filterBuffer) > 0)
                        {
                            memset(filterBuffer, 0, sizeof(filterBuffer));
                        }
                        strncpy_s(filterBuffer, clipboardText, IM_ARRAYSIZE(filterBuffer) - 1);
                    }
                }

                ImGui::SameLine();
                if (ImGui::Button("Clear ##33"))
                {
                    memset(filterBuffer, 0, sizeof(filterBuffer));
                }

                ImGui::BeginChild("SongSelection", ImVec2(0, 200), true, ImGuiWindowFlags_None);
                // Child window with a height of 400

                toLowercaseInPlace(filterBuffer);

                static std::string selectedSongName; // Track the selected song name

                for (const auto& [songname, filename] : audioConfig)
                {
                    char lowerSongName[128];
                    strcpy_s(lowerSongName, songname.c_str());
                    toLowercaseInPlace(lowerSongName);

                    if (IsSelectableFiltered(lowerSongName, filterBuffer))
                    {
                        bool isSelected = (selectedSongName == songname);
                        if (ImGui::Selectable(songname.c_str(), isSelected))
                        {
                            strncpy_s(globals::audio::blobNameAudioBuffer, filename.c_str(), sizeof(globals::audio::blobNameAudioBuffer) - 1);
                            selectedSongName = songname;
                            ImGui::SetClipboardText(songname.c_str()); // Optional: Copy songname to clipboard
                        }
                    }
                }

                ImGui::EndChild();
            }
            #endif


            ImAdd::EndHighlightGroup();
            ImGui::Indent(-10);
        }

        if (ImAdd::Button("HEAT All", ImVec2(-0.1f, 0)))
        {
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::PlayAudioSampleAll);
        }
        ImGui::SetItemTooltip("Play an audio for all players.");

        if (ImAdd::Button("Stop Audio", ImVec2(-0.1f, 0)))
        {
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::StopCachedAudioSample);
        }
        ImGui::SetItemTooltip("Stop last audio for all players.");

        if (ImAdd::Button("Clean Up Bosses", ImVec2(-0.1f, 0)))
        {
            EnqueueCallback(std::chrono::milliseconds(300), globals::onUpdate::ExecutionCondition::ExecLoaded,
                            Callbacks::CleanGarbagePrefabs);
        }
        ImGui::SetItemTooltip("Attempt to destroy all spawned boss prefabs.");
        
        ImGui::Separator();

        ImAdd::ToggleButtonClassic("Skill Gap", &globals::skillGapToggle);
        ImGui::SetItemTooltip(
            "Auto-Crash all detected vmods. \nSound effect will play when crash triggers. \n Customizable in Mocha/vmod.wav");

        ImGui::BeginDisabled();

        ImGui::SameLine();
        ImAdd::ToggleButtonClassic("Auto Vanish", &globals::autoVanishToggle);
        ImGui::SetItemTooltip("Vanish Automatically.");

        ImGui::SameLine();
        ImAdd::ToggleButtonClassic("Cloak", &globals::cloakToggle);
        ImGui::SetItemTooltip("Vanish automatically when a vmod is detected.");

        ImGui::EndDisabled();

        ImGui::Separator();

        ImGui::BeginDisabled();
        
        ImAdd::ToggleButtonClassic("Own Room Keys", &globals::Ihooks::DoesLocalPlayerOwnKey);
        ImGui::SetItemTooltip("Own all room keys locally.");

        ImAdd::ToggleButtonClassic("Local Developer", &globals::Ihooks::get_IsDeveloper);
        ImGui::SetItemTooltip("Be \"Developer\" locally.");

        ImAdd::ToggleButtonClassic("Local Moderator", &globals::Ihooks::get_LocalAccountIsModerator);
        ImGui::SetItemTooltip("Be  \"Moderator\" locally.");

        ImAdd::ToggleButtonClassic("Local RR+", &globals::Ihooks::get_HasActiveRRPlusSubscription);
        ImGui::SetItemTooltip("Own RR+ locally.");

        ImAdd::ToggleButtonClassic("Disable Voice Moderation", &globals::Ihooks::DisableToxMod);
        ImGui::SetItemTooltip("Disable voice moderation.");

        ImGui::EndDisabled();
        
        ImAdd::ToggleButtonClassic("Disable CircuitsV2", &globals::disableCircuits);
        ImGui::SetItemTooltip("Disable circuits V2.");

        if (globals::disableCircuits)
        {
            ImGui::Indent(10);
            ImAdd::BeginHighlightGroup();
            ImAdd::ToggleButtonClassic("Harsh Mode", &globals::destroyCircuitsManager);
            ImGui::SetItemTooltip("Fuck Circuits. \nThis is irreversible. \nThis causes alot of issues. \nOnly enable post load or you will crash.");
            ImAdd::EndHighlightGroup();
            ImGui::Indent(-10);
        }
        
        ImAdd::ToggleButtonClassic("Aura Check", &globals::makerPenDropperToggle);
        ImGui::SetItemTooltip("SO WHEN SHUSH SITS ON HIS ASS HE GETS 10000 AURA \nBUT WHEN I WIN A 20v1 I GET -10000 AURA?? \nI SEE HOW IT IS.");
        
        if (globals::makerPenDropperToggle)
        {
            ImAdd::ToggleButtonClassic("Announce Negative Aura", &globals::makerPenDropperAnnounceToggle);
            ImGui::SetItemTooltip("Announce negative aura events.");
        }
    }
    ImGui::EndChild();
}
